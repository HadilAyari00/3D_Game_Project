<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Babylon.js Game Prototype</title>
    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>

    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
  </head>

  <body>
    <canvas id="renderCanvas"></canvas>
    <div
      id="loadingScreen"
      style="
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
      "
    >
      <h1 style="color: white">Loading...</h1>
    </div>

    <script>
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);

      let gameActive = true;

      BABYLON.DefaultLoadingScreen.prototype.displayLoadingUI = function () {
        if (document.getElementById("customLoadingScreenDiv")) {
          document.getElementById("customLoadingScreenDiv").style.display =
            "initial";
          console.log("reload");
          // Do not add a loading screen if there is already one
          return;
        }

        console.log("new");

        this._loadingDiv = document.createElement("div");
        this._loadingDiv.id = "customLoadingScreenDiv";
        this._loadingDiv.innerHTML =
          "<img src='https://art.pixilart.com/028d26275ff2b38.gif' />";
        var customLoadingScreenCss = document.createElement("style");
        customLoadingScreenCss.type = "text/css";
        customLoadingScreenCss.innerHTML = `
    #customLoadingScreenDiv{
        background-color: #FFFFFFcc;
        color: white;
        font-size:50px;
        text-align:center;
    }
    `;
        document
          .getElementsByTagName("head")[0]
          .appendChild(customLoadingScreenCss);
        this._resizeLoadingUI();
        window.addEventListener("resize", this._resizeLoadingUI);
        document.body.appendChild(this._loadingDiv);
      };

      BABYLON.DefaultLoadingScreen.prototype.hideLoadingUI = function () {
        document.getElementById("customLoadingScreenDiv").style.display =
          "none";
        console.log("scene is now loaded");
      };
      engine.displayLoadingUI();

      let player;
      const projectiles = [];
      const enemies = [];
      let playerBoundingBox;

      const createPlayer = async function (scene) {
        const result = await BABYLON.SceneLoader.ImportMeshAsync(
          "",
          "./models/ufo/",
          "baby_cute_alien.glb",
          scene
        );
        const root = new BABYLON.TransformNode("root", scene);
        const rotationQuaternion = new BABYLON.Quaternion();
        BABYLON.Quaternion.RotationAxisToRef(
          BABYLON.Axis.Y,
          BABYLON.Tools.ToRadians(90),
          rotationQuaternion
        );
        result.meshes.forEach((mesh) => {
          mesh.parent = root;
          mesh.scaling = new BABYLON.Vector3(0.75, 0.75, 0.75);
          mesh.rotate(BABYLON.Axis.X, BABYLON.Tools.ToRadians(-90));
        });
        root.position.y = 1;
        root.frontVector = new BABYLON.Vector3(0, 0, 1);

        playerBoundingBox = BABYLON.MeshBuilder.CreateBox(
          "playerBoundingBox",
          { size: 2 },
          scene
        );
        playerBoundingBox.visibility = 0;
        playerBoundingBox.position = root.position.clone(); // Set the position of the bounding box to match the root node
        playerBoundingBox.checkCollisions = true;

        // Add a physics impostor to the player's bounding box
        playerBoundingBox.physicsImpostor = new BABYLON.PhysicsImpostor(
          playerBoundingBox,
          BABYLON.PhysicsImpostor.BoxImpostor,
          { mass: 1, restitution: 0.9 },
          scene
        );

        return root;
      };
      const createFollowCamera = function (scene, target) {
        const camera = new BABYLON.FollowCamera(
          "followCamera",
          target.position,
          scene
        );
        camera.radius = 10;
        camera.heightOffset = 5;
        camera.rotationOffset = 180;
        camera.cameraAcceleration = 0.05;
        camera.maxCameraSpeed = 5;
        camera.lockedTarget = target;
        camera.attachControl(canvas, true);
        return camera;
      };

      // Add event listeners for mouse movement
      let isMouseButtonDown = false;
      canvas.addEventListener("mousedown", (event) => {
        isMouseButtonDown = true;
      });
      canvas.addEventListener("mouseup", (event) => {
        isMouseButtonDown = false;
      });
      canvas.addEventListener("mousemove", (event) => {
        if (isMouseButtonDown) {
          const camera = scene.activeCamera;
          camera.rotationOffset += event.movementX * 0.25;

          // Calculate the new height offset
          const newHeightOffset = camera.heightOffset - event.movementY * 0.25;

          // Compute the new camera position in world space
          const alpha = BABYLON.Tools.ToRadians(camera.alpha);
          const beta = BABYLON.Tools.ToRadians(camera.beta);
          const target = camera.lockedTarget;
          const radius = camera.radius;
          const position = new BABYLON.Vector3(
            target.x + radius * Math.sin(alpha) * Math.cos(beta),
            target.y + radius * Math.sin(beta),
            target.z + radius * Math.cos(alpha) * Math.cos(beta)
          );

          // Check if the new camera position is above the ground level
          if (position.y >= 1) {
            camera.heightOffset = newHeightOffset;
          }
        }
      });

      function createLight(scene) {
        const light = new BABYLON.HemisphericLight(
          "light",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        light.intensity = 0.7;
      }

      function facePlayer(enemy, player) {
        const direction = player.position.subtract(enemy.position);
        direction.y = 0;
        direction.normalize();

        const angle = Math.atan2(direction.x, direction.z);
        enemy.rotation.y = angle;
      }

      async function createEnemies(scene) {
        const scalingFactor = 0.015;
        const numEnemies = 15;
        const spawnRange = 100; // Increase this to make enemies spawn further away
        const enemySpeed = 1; // Increase this to make enemies faster

        const container = await BABYLON.SceneLoader.LoadAssetContainerAsync(
          "./models/enemies/",
          "untitled1.glb",
          scene
        );

        const root = container.meshes[0];
        root.scaling = new BABYLON.Vector3(
          scalingFactor,
          scalingFactor,
          scalingFactor
        );

        const animationGroup = container.animationGroups[0];

        for (let i = 0; i < numEnemies; i++) {
          const enemy = root.clone("enemy" + i);
          enemy.position = new BABYLON.Vector3(
            Math.random() * spawnRange - spawnRange / 2,
            1,
            Math.random() * spawnRange - spawnRange / 2
          );

          // Prevent spawning too close to the player
          while (
            BABYLON.Vector3.Distance(enemy.position, player.position) < 10
          ) {
            enemy.position = new BABYLON.Vector3(
              Math.random() * spawnRange - spawnRange / 2,
              1,
              Math.random() * spawnRange - spawnRange / 2
            );
          }

          const enemyBoundingBox = BABYLON.MeshBuilder.CreateBox(
            "enemyBoundingBox" + i,
            { size: 2 },
            scene
          );
          enemyBoundingBox.visibility = 0;
          enemyBoundingBox.parent = enemy;
          enemyBoundingBox.checkCollisions = true;

          // Make the enemy face the player when spawned
          enemy.lookAt(
            new BABYLON.Vector3(
              player.position.x,
              enemy.position.y,
              player.position.z
            )
          );

          enemy.rotate(
            BABYLON.Axis.Y,
            BABYLON.Tools.ToRadians(-60),
            BABYLON.Space.LOCAL
          );

          enemies.push(enemy);

          // Clone and reassign the skeleton
          const clonedSkeleton = container.skeletons[0].clone();
          enemy.skeleton = clonedSkeleton;

          // Clone the animation group and reassign the targeted animation
          const clonedAnimationGroup = animationGroup.clone();
          const targetedAnimation = clonedAnimationGroup.targetedAnimations[0];
          targetedAnimation.target = clonedSkeleton;
          clonedAnimationGroup.start(true);
          engine.hideLoadingUI();
        }
      }

      const createScene = async function () {
        const loadingScreen = document.getElementById("loadingScreen");
        loadingScreen.style.display = "flex";

        const scene = new BABYLON.Scene(engine);
        createLight(scene);
        const physicsPlugin = new BABYLON.CannonJSPlugin();
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), physicsPlugin);

        const loadLandscape = async (scene) => {
          const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "",
            "./models/landscape/",
            "layout_place.glb",
            scene
          );
          const landscape = result.meshes[0];
          landscape.checkCollisions = true;
          // Adjust the scaling and position if necessary
          landscape.scaling = new BABYLON.Vector3(0.02, 0.02, 0.02);
          landscape.position = new BABYLON.Vector3(0, 0, 0);
          return landscape;
        };

        // Load the landscape model
        const landscape = await loadLandscape(scene);

        function getHeightAtPosition(scene, landscape, position) {
          const rayOrigin = position.clone();
          rayOrigin.y = 100; // A high starting point
          const rayDirection = new BABYLON.Vector3(0, -1, 0);
          const rayLength = 200; // Enough length to reach the ground
          const ray = new BABYLON.Ray(rayOrigin, rayDirection, rayLength);

          const hitInfo = scene.pickWithRay(ray, (mesh) => mesh === landscape);

          if (hitInfo.hit) {
            return hitInfo.pickedPoint.y;
          } else {
            return null;
          }
        }

        // Create a dummy target for the camera
        const dummyTarget = new BABYLON.TransformNode("dummyTarget", scene);
        dummyTarget.position.y = 1;

        // Define the camera before loading the model
        const followCamera = createFollowCamera(scene, dummyTarget);
        scene.activeCamera = followCamera;

        // Load the player model

        createPlayer(scene)
          .then((playerMesh) => {
            player = playerMesh;

            const followCamera = createFollowCamera(scene, playerMesh);
            scene.activeCamera = followCamera;

            // Play animation if available
            if (scene.animationGroups.length > 0) {
              const animationGroup = scene.animationGroups[0];
              animationGroup.play(true);
            }
          })
          .catch((error) => {
            console.error("Error loading player model:", error);
            return;
          });

        createEnemies(scene);

        const projectileMaterial = new BABYLON.StandardMaterial(
          "projectileMaterial",
          scene
        );
        projectileMaterial.diffuseColor = new BABYLON.Color3.Purple();

        window.addEventListener("keydown", function (event) {
          if (event.key === " ") {
            const projectile = BABYLON.MeshBuilder.CreateSphere(
              "projectile",
              { diameter: 1 },
              scene
            );
            projectile.creationTime = Date.now();
            projectile.position = player.position
              .add(player.frontVector.multiplyByFloats(2, 2, 2))
              .add(new BABYLON.Vector3(0, 1, 0));
            projectile.material = projectileMaterial;
            projectile.direction = new BABYLON.Vector3(
              player.frontVector.x,
              0,
              player.frontVector.z
            );

            // Add a physics impostor to the projectile
            projectile.physicsImpostor = new BABYLON.PhysicsImpostor(
              projectile,
              BABYLON.PhysicsImpostor.SphereImpostor,
              { mass: 1, restitution: 0.9 },
              scene
            );

            // Apply an impulse to the projectile in the direction it was fired
            projectile.physicsImpostor.applyImpulse(
              projectile.direction.scale(30),
              projectile.getAbsolutePosition()
            );
            projectiles.push(projectile);
          }
        });

        let trashBagModel;
        let trashBagSpawnTimer = 0;

        const loadTrashBagModel = async () => {
          const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "",
            "./models/trashbag/",
            "low_poly_trash_bag.glb",
            scene
          );
          trashBagModel = result.meshes[0];
          trashBagModel.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01); // Adjust the scaling factor as needed
          trashBagModel.setEnabled(false);
        };

        loadTrashBagModel();

        let trashBags = [];

        const spawnTrashBag = (position, direction) => {
          const trashBag = trashBagModel.clone();
          trashBag.setEnabled(true);
          trashBag.position = position.clone();
          trashBag.direction = direction.clone();

          // Add a physics impostor to the trash bag
          trashBag.physicsImpostor = new BABYLON.PhysicsImpostor(
            trashBag,
            BABYLON.PhysicsImpostor.BoxImpostor,
            {
              mass: 1,
              restitution: 0,
              friction: 1,
            },
            scene
          );

          trashBagModel.scaling = new BABYLON.Vector3(0.01, 0.01, 0.01); // Adjust the scaling factor as needed

          // Adjust the angle to be a bit higher
          const angleFactor = 0.1;
          trashBag.direction.y += angleFactor;

          // Apply an impulse to the trash bag in the direction it was fired
          trashBag.physicsImpostor.applyImpulse(
            trashBag.direction.scale(30),
            trashBag.getAbsolutePosition()
          );

          // Set up the onCollideEvent for the trash bag's physics impostor
          trashBag.physicsImpostor.onCollideEvent = (collider, collided) => {
            if (collided === landscape.physicsImpostor) {
              trashBag.physicsImpostor.setLinearVelocity(
                new BABYLON.Vector3(0, 0, 0)
              );
              trashBag.physicsImpostor.setAngularVelocity(
                new BABYLON.Vector3(0, 0, 0)
              );
            }
          };

          // Set up a ray to check for collisions below the trash bag
          const rayOrigin = trashBag.position.clone();
          rayOrigin.y += 1; // Slightly above the trash bag's position
          const rayDirection = new BABYLON.Vector3(0, -1, 0);
          const rayLength = 5; // The length of the ray, adjust as needed
          const ray = new BABYLON.Ray(rayOrigin, rayDirection, rayLength);

          // Check for collisions with the landscape
          const hitInfo = scene.pickWithRay(ray, (mesh) => mesh === landscape);

          // If the ray intersects the landscape, set the trash bag's position to the picked point
          if (hitInfo.hit) {
            trashBag.position.y = hitInfo.pickedPoint.y + 1; // Add some offset to avoid z-fighting
          }

          trashBag.physicsImpostor.registerOnPhysicsCollide(
            playerBoundingBox.physicsImpostor,
            () => {
              if (trashBag.canHitPlayer) {
                // Check if the trash bag can hit the player
                console.log("hit !");
                // Reduce player HP when there's a collision with the trash bag
                playerHP -= 20;
                hpBar.width = (200 * (playerHP / 100)).toString() + "px";
                if (playerHP <= 0) {
                  hpBar.background = "red";
                  console.log("dead !");
                  gameActive = false;
                  const gameOverText = new BABYLON.GUI.TextBlock();
                  gameOverText.text = "GAME OVER";
                  gameOverText.color = "red";
                  gameOverText.fontSize = 48;
                  gameOverText.verticalAlignment =
                    BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
                  gameOverText.horizontalAlignment =
                    BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                  advancedTexture.addControl(gameOverText);
                }
                trashBag.canHitPlayer = false; // Set the flag to prevent further collisions with the player
              }
            }
          );

          trashBag.physicsImpostor.registerOnPhysicsCollide(
            landscape.physicsImpostor,
            () => {
              trashBag.physicsImpostor.setLinearVelocity(
                new BABYLON.Vector3(0, 0, 0)
              );
              trashBag.physicsImpostor.setAngularVelocity(
                new BABYLON.Vector3(0, 0, 0)
              );
            }
          );

          trashBag.canHitPlayer = true;
          trashBags.push(trashBag);
        };

        const advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        const hpBarBorder = new BABYLON.GUI.Rectangle("hpBarBorder");
        hpBarBorder.width = "204px";
        hpBarBorder.height = "62px";
        hpBarBorder.cornerRadius = 5;
        hpBarBorder.color = "white";
        hpBarBorder.thickness = 2;
        hpBarBorder.background = "transparent";
        hpBarBorder.top = "50px";
        hpBarBorder.left = "10px";
        hpBarBorder.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        hpBarBorder.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;

        const hpBarLabel = new BABYLON.GUI.TextBlock();
        hpBarLabel.text = "Health";
        hpBarLabel.color = "white";
        hpBarLabel.fontSize = 16;
        hpBarLabel.top = "-20px";
        hpBarLabel.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        hpBarBorder.addControl(hpBarLabel);

        const hpBar = new BABYLON.GUI.Rectangle("hpBar");
        hpBar.width = "200px";
        hpBar.height = "20px";
        hpBar.cornerRadius = 5;
        hpBar.color = "transparent";
        hpBar.thickness = 0;
        hpBar.background = "green";
        hpBar.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        hpBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;

        const hpBarContainer = new BABYLON.GUI.Rectangle("hpBarContainer");
        hpBarContainer.width = "200px";
        hpBarContainer.height = "20px";
        hpBarContainer.cornerRadius = 5;
        hpBarContainer.color = "white";
        hpBarContainer.thickness = 2;
        hpBarContainer.background = "transparent";
        hpBarContainer.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        hpBarContainer.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;

        advancedTexture.addControl(hpBarBorder);
        hpBarBorder.addControl(hpBarContainer);
        hpBarContainer.addControl(hpBar);

        let playerHP = 100;

        let treeTemplate;
        const loadTreeModel = async () => {
          const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "",
            "./models/tree/",
            "low-poly_simple_trees.glb",
            scene
          );
          treeTemplate = result.meshes[0];
          treeTemplate.scaling = new BABYLON.Vector3(0.005, 0.005, 0.005);
          treeTemplate.setEnabled(false);
        };

        loadTreeModel();

        scene.registerBeforeRender(function () {
          if (player && playerBoundingBox) {
            // Update the position of the player's bounding box to follow the player
            playerBoundingBox.position = player.position.clone();
          }

          const moveFactor = 0.3;
          if (inputStates.up) {
            player.position.addInPlace(
              player.frontVector.multiplyByFloats(moveFactor, 0, moveFactor)
            );
          }

          if (inputStates.down) {
            player.position.addInPlace(
              player.frontVector.multiplyByFloats(-moveFactor, 0, -moveFactor)
            );
          }

          if (inputStates.left) {
            player.rotation.y -= 0.02;
            player.frontVector = new BABYLON.Vector3(
              Math.sin(player.rotation.y),
              0,
              Math.cos(player.rotation.y)
            );
          }

          if (inputStates.right) {
            player.rotation.y += 0.02;
            player.frontVector = new BABYLON.Vector3(
              Math.sin(player.rotation.y),
              0,
              Math.cos(player.rotation.y)
            );
          }

          // Trash bag spawning timer
          trashBagSpawnTimer += scene.getEngine().getDeltaTime();
          if (trashBagSpawnTimer >= 1000 && trashBagModel) {
            const randomEnemyIndex = Math.floor(Math.random() * enemies.length);
            const randomEnemy = enemies[randomEnemyIndex];

            if (randomEnemy && !randomEnemy.isTree) {
              const direction = player.position
                .subtract(randomEnemy.position)
                .normalize();
              spawnTrashBag(randomEnemy.position, direction);
            }
            trashBagSpawnTimer = 0;
          }

          trashBags.forEach((trashBag, index) => {
            const rayOrigin = trashBag.position.clone();
            rayOrigin.y += 2; // Slightly above the trash bag's position
            const rayDirection = new BABYLON.Vector3(0, -1, 0);
            const rayLength = 5; // The length of the ray, adjust as needed
            const ray = new BABYLON.Ray(rayOrigin, rayDirection, rayLength);

            const hitInfo = scene.pickWithRay(
              ray,
              (mesh) => mesh === landscape
            );

            if (hitInfo.hit) {
              // Set the trash bag's position to the hit point and add a small offset to keep it above the ground
              trashBag.position.y = hitInfo.pickedPoint.y + 0.1;

              if (!trashBag.collisionHandled) {
                trashBag.physicsImpostor.setLinearVelocity(
                  new BABYLON.Vector3(0, 0, 0)
                );
                trashBag.physicsImpostor.setAngularVelocity(
                  new BABYLON.Vector3(0, 0, 0)
                );
                trashBag.physicsImpostor.mass = 0; // Make the trash bag immovable
                trashBag.collisionHandled = true;
              }

              if (!trashBag.collisionEventAdded) {
                trashBag.physicsImpostor.registerOnPhysicsCollide(
                  playerBoundingBox.physicsImpostor,
                  () => {
                    if (trashBag.isVisible) {
                      trashBag.isVisible = false;
                      trashBag.setEnabled(false);
                      console.log("Player collected a trash bag!");
                    }
                  }
                );
                trashBag.collisionEventAdded = true;
              }
            } else {
              trashBag.collisionHandled = false;
            }
          });

          const now = Date.now();
          for (let i = 0; i < projectiles.length; i++) {
            const projectile = projectiles[i];
            projectile.position.addInPlace(
              projectile.direction.multiplyByFloats(0.5, 0.5, 0.5)
            );

            // Remove projectile if it's more than 3 seconds old
            if (now - projectile.creationTime > 3000) {
              projectile.dispose();
              projectiles.splice(i, 1);
              i--;
              continue; // Skip to next iteration
            }

            // Collision check between projectiles and enemies
            for (let j = 0; j < enemies.length; j++) {
              const enemy = enemies[j];
              if (
                BABYLON.Vector3.Distance(projectile.position, enemy.position) <=
                1.5
              ) {
                projectile.dispose();
                projectiles.splice(i, 1);
                i--;

                // Set enemy isHit to true and remove the projectile
                enemy.isHit = true;
                break;
              }
            }
          }

          const enemyMoveFactor = 0.01;
          enemies.forEach((enemy) => {
            // If enemy is hit, turn into a tree and stop movement
            if (enemy.isHit) {
              if (!enemy.isTree) {
                const tree = treeTemplate.clone();
                tree.setEnabled(true);
                tree.position = enemy.position.clone();
                tree.position.y -= 1; // Adjust the tree Y position so it doesn't go into the ground
                tree.scaling = new BABYLON.Vector3(1.2, 1.2, 1.2); // Adjust tree scaling as needed
                enemy.dispose();
                enemy.isTree = true;
              }
              return; // Skip the rest of the loop for this enemy
            }

            const direction = player.position.subtract(enemy.position);
            direction.y = 0;
            direction.normalize();

            enemy.position.addInPlace(
              direction.multiplyByFloats(enemyMoveFactor, 0, enemyMoveFactor)
            );

            // Rotate the enemy to face the direction they're moving in
            const lookAtPosition = new BABYLON.Vector3(
              player.position.x,
              enemy.position.y,
              player.position.z
            );
            const quat = new BABYLON.Quaternion();
            BABYLON.Quaternion.RotationYawPitchRollToRef(0, 0, 0, quat);
            enemy.lookAt(lookAtPosition, 0, quat.toEulerAngles().y, 0);

            // Add the -45 degrees rotation around the Y-axis after the lookAt function
            enemy.rotate(
              BABYLON.Axis.Y,
              BABYLON.Tools.ToRadians(-65),
              BABYLON.Space.LOCAL
            );
          });
        });

        return scene;
      };
      BABYLON.SceneLoader.OnPluginActivatedObservable.addOnce((loader) => {
        loader.onCompleteObservable.addOnce(() => {
          loadingScreen.style.display = "none";
        });
      });

      (async function () {
        const scene = await createScene();

        engine.runRenderLoop(function () {
          if (gameActive) scene.render();
        });

        window.addEventListener("resize", function () {
          engine.resize();
        });
      })();

      let inputStates = {
        left: false,
        right: false,
        up: false,
        down: false,
      };

      window.addEventListener("keydown", function (event) {
        if (player) {
          if (event.key === "q" || event.key === "Q") {
            inputStates.left = true;
          } else if (event.key === "d" || event.key === "D") {
            inputStates.right = true;
          } else if (event.key === "z" || event.key === "Z") {
            inputStates.up = true;
          } else if (event.key === "s" || event.key === "S") {
            inputStates.down = true;
          }
        }
      });

      window.addEventListener("keyup", function (event) {
        if (player) {
          if (event.key === "q" || event.key === "Q") {
            inputStates.left = false;
          } else if (event.key === "d" || event.key === "D") {
            inputStates.right = false;
          } else if (event.key === "z" || event.key === "Z") {
            inputStates.up = false;
          } else if (event.key === "s" || event.key === "S") {
            inputStates.down = false;
          }
        }
      });
    </script>
  </body>
</html>
